<?php

namespace App\Console\Commands\Parsers\Xml;

use App\Commands\CommitCurrentUnitOfWork;
use App\Commands\CreateAsset;
use App\Commands\CreateVulnerability;
use App\Commands\CreateVulnerabilityReference;
use App\Commands\CreateOpenPort;
use App\Contracts\CollectsScanOutput;
use App\Contracts\SystemComponent;
use App\Entities\Asset;
use App\Entities\File;
use App\Entities\OpenPort;
use App\Entities\User;
use App\Entities\Vulnerability;
use App\Entities\VulnerabilityReferenceCode;
use App\Repositories\FileRepository;
use App\Services\Parsers\AbstractXmlParserService;
use App\Services\XmlParserFactoryService;
use Doctrine\ORM\ORMException;
use Illuminate\Console\Command;
use Illuminate\Contracts\Filesystem\FileNotFoundException;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Auth;
use League\Tactician\CommandBus;
use Exception;

class ParseUnprocessedXmlCommand extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'parse:xml';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Parse XML scan output. It will parse all uploaded and unprocessed files';
    
    /** @var FileRepository */
    protected $repository;

    /** @var CommandBus */
    protected $bus;

    /**
     * Create a new command instance.
     *
     * @param FileRepository $fileRepository
     * @param CommandBus $bus
     */
    public function __construct(FileRepository $fileRepository, CommandBus $bus)
    {
        parent::__construct();
        $this->repository = $fileRepository;
        $this->bus        = $bus;
    }

    /**
     * Execute the console command.
     *
     * @return mixed
     */
    public function handle()
    {
        // Get unprocessed files grouped by workspace ID
        $filesByWorkspace = $this->getRepository()->findUnprocessed();
        if ($filesByWorkspace->isEmpty()) {
            $this->info("No files to process at the moment.");
            return true;
        }

        // Iterate over the files
        $filesByWorkspace->each(function($file, $offset) {
            /** @var File $file */
            return $this->processFile($file);
        });

        // Some entities won't have been flushed immediately, flush all unflushed entities
        $command = new CommitCurrentUnitOfWork();
        try {
            $this->getBus()->handle($command);
        } catch (ORMException $e) {
            $this->error("Failed to persist entities imported from the given files!");
        }

        return true;
    }

    /**
     * Process a single NMAP file
     *
     * @param File $file
     * @return bool
     */
    protected function processFile(File $file)
    {
        try {
            // Get the relevant parser service based on the name of the scanner
            /** @var AbstractXmlParserService $service */
            $service = XmlParserFactoryService::getParserService($file->getScannerApp()->getName());

            // Process the file and extract a Collection of XML models
            /** @var Collection $xmlParserModels */
            $xmlParserModels = $service->processXmlFile($file);
        } catch (FileNotFoundException $e) {
            $this->error("Error processing file: $file: {$e->getMessage()}");
            return true;
        }

        // If there were no models generated show a warning message
        if ($xmlParserModels->isEmpty()) {
            $this->warn("No models generated by file: $file.");
            return true;
        }

        // Intialise some counters
        $counters = new Collection([
            Asset::class                      => 0,
            Vulnerability::class              => 0,
            VulnerabilityReferenceCode::class => 0,
            OpenPort::class                   => 0,
        ]);

        // Get the Workspace ID from the file entity
        $workspaceId = $file->getWorkspaceId();

        // Authenticate the User who uploaded the file so that their permissions will be used for applying any
        // operations that result from processing the file
        $currentUser = Auth::user();
        $fileUser    = $file->getUser();
        if (empty($currentUser) || !($currentUser instanceof User)
            || $currentUser->getId() !== $fileUser->getId()) {

            Auth::login($fileUser);
            
        }

        // Iterate over each model, extract and persist the relevant entities
        $xmlParserModels->each(function($model, $offset) use ($workspaceId, $file, $counters) {
            $this->processXmlParserModel($model, $workspaceId, $counters, $file);
            return true;
        });

        // Move the file to the processed location
        $service->moveFileToProcessed($file);

        // No Assets successfully created :( reset the service models and return
        if ($counters->get(Asset::class, 0) === 0) {
            $this->error("Did not successfully create any Assets from file: {$file->getPath()}");
            $service->resetModels();
            return true;
        }

        // More Assets were found in the file that were created, i.e. some attempts to create Assets failed :/
        if ($counters->get(Asset::class, 0) !== $xmlParserModels->count()) {
            $failed = $xmlParserModels->count() - $counters->get(Asset::class, 0);
            $this->warn(
                "Failed to create $failed of {$xmlParserModels->count()} Assets found in file: {$file->getPath()}"
            );
        }

        // Compile a final message to show on the command line
        $message = "Successfully created/updated {$counters->get(Asset::class)} Assets";
        if ($counters->get(OpenPort::class, 0) !== 0) {
            $message .= ", {$counters->get(OpenPort::class)} Open Ports";
        }

        if ($counters->get(Vulnerability::class, 0) !== 0) {
            $message .= ", {$counters->get(Vulnerability::class)} Vulnerabilities";
        }

        if ($counters->get(VulnerabilityReferenceCode::class, 0) !== 0) {
            $message .= ", {$counters->get(VulnerabilityReferenceCode::class)} Vulnerability Reference Codes";
        }

        $message .= " found in file: {$file->getPath()}";

        // All Assets that were found were successfully created :)
        $this->info($message);

        // Reset the collection of Models to an empty Collection in preparation from processing the next file.
        $service->resetModels();

        return true;
    }

    /**
     * Process the XML Parser Model
     *
     * @param CollectsScanOutput $model
     * @param int $workspaceId
     * @param Collection $counters
     * @param File $file
     * @return bool
     */
    protected function processXmlParserModel(
        CollectsScanOutput $model, int $workspaceId, Collection $counters, File $file
    ): bool
    {
        // Instantiate a CreateAsset command and attempt to execute the command
        /** @var CollectsScanOutput $model */
        $assetDetails = $model->exportForAsset();

        // Get vulnerability, vulnerability reference and system information
        $vulnerabilityDetails    = $model->exportForVulnerability();
        $vulnerabilityRefDetails = $model->exportForVulnerabilityReference();
        $openPortDetails         = $model->exportForOpenPort();

        // Save the Asset
        $asset = $this->sendCommandToBus(CreateAsset::class, $workspaceId, $assetDetails);

        // Make sure we got an Asset entity back from the command. If not, we can't continue, because Open Ports
        // and Vulnerabilities need to be related to an Asset entity
        if (empty($asset) || !($asset instanceof Asset)) {
            return true;
        }

        // Add the asset to the collection
        $currentAssetCount = $counters->get(Asset::class, 0);
        $counters->put(Asset::class, $currentAssetCount + 1);

        // Iterate over all Open Port entries that were found in the file
        $openPortDetails->each(function ($openPortDetails, $offset) use ($file, $asset, $counters) {
            // Call the CreateOpenPort command for each Open Port found in the XML
            $openPort = $this->sendCommandToBus(
                CreateOpenPort::class, $asset->getId(), $openPortDetails, $file, true
            );

            // If we got an OpenPort entity from the command increment the counter
            if (!empty($openPort)) {
                $currentOpenPortCount = $counters->get(OpenPort::class, 0);
                $counters->put(OpenPort::class, $currentOpenPortCount + 1);
            }
        });

        // Call the CreateVulnerability command
        $vulnerability = $this->sendCommandToBus(
            CreateVulnerability::class, $asset->getId(), $vulnerabilityDetails, $file
        );

        // If we did not get a Vulnerability Entity back from the command we cannot continue because
        // VulnerabilityReferenceCodes must have a related Vulnerability
        if (empty($vulnerability) || !($vulnerability instanceof Vulnerability)) {
            return true;
        }

        // Increment the Vulnerability count
        $currentVulnerabilityCount = $counters->get(Vulnerability::class, 0);
        $counters->put(Vulnerability::class, $currentVulnerabilityCount + 1);

        // If there is associated vulnerability reference data in the model, save a new vulnerability reference
        $vulnerabilityReference = $this->sendCommandToBus(
            CreateVulnerabilityReference::class, $vulnerability->getId(), $vulnerabilityRefDetails
        );

        // Increment the VulnerabilityReferenceCode counter if we got a VulnerabilityReferenceCode entity from the
        // CreateVulnerabilityReference command
        if (!empty($vulnerabilityReference)) {
            $currentVulnerabilityReferenceCount = $counters->get(VulnerabilityReferenceCode::class, 0);
            $counters->put(VulnerabilityReferenceCode::class, $currentVulnerabilityReferenceCount + 1);
        }

        return true;
    }

    /**
     * Instantiate the relevant command and send it over the command bus
     *
     * @param string $commandClass
     * @param int $id
     * @param Collection $details
     * @param File $file
     * @param bool $multiMode
     * @return SystemComponent|false
     */
    public function sendCommandToBus(
        string $commandClass, int $id, Collection $details, File $file = null, bool $multiMode = false
    )
    {
        // Make sure we got a valid command class
        if (!class_exists($commandClass)) {
            $this->error("Could not find command class: $commandClass.");
            return false;
        }

        // Make sure we got the necessary foreign key and details for the command
        if (!isset($id) || $details->isEmpty()) {
            $this->warn("A required parameter to be used in the command '$commandClass' is not set.");
            return false;
        }

        // Add the file to the details (this will not be used in some cases)
        $details->put('file', $file);

        // Try to execute the command and catch any exceptions
        try {
            $command = new $commandClass($id, $details->toArray(), $multiMode);
            return $this->getBus()->handle($command);
        } catch (Exception $e) {
            $this->error("Error: {$e->getMessage()} when handling command: $commandClass.");
            return false;
        }
    }

    /**
     * @return FileRepository
     */
    public function getRepository()
    {
        return $this->repository;
    }

    /**
     * @return CommandBus
     */
    public function getBus()
    {
        return $this->bus;
    }
}
