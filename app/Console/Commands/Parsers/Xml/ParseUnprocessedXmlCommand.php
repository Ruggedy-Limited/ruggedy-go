<?php

namespace App\Console\Commands\Parsers\Xml;

use App\Commands\CreateAsset;
use App\Commands\CreateSomething;
use App\Commands\CreateVulnerability;
use App\Commands\CreateVulnerabilityReference;
use App\Commands\CreateSystemInformation;
use App\Contracts\CollectsScanOutput;
use App\Contracts\SystemComponent;
use App\Entities\Asset;
use App\Entities\File;
use App\Entities\SystemInformation;
use App\Entities\User;
use App\Entities\Vulnerability;
use App\Entities\VulnerabilityReferenceCode;
use App\Exceptions\InvalidInputException;
use App\Repositories\FileRepository;
use App\Services\Parsers\AbstractXmlParserService;
use App\Services\XmlParserFactoryService;
use Doctrine\ORM\EntityManager;
use Illuminate\Console\Command;
use Illuminate\Contracts\Filesystem\FileNotFoundException;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Auth;
use League\Tactician\CommandBus;
use Exception;

class ParseUnprocessedXmlCommand extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'parse:xml';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Parse NMAP XML output. It will parse all files in storage/scans/xml/nmap';

    /** @var EntityManager */
    protected $em;
    
    /** @var FileRepository */
    protected $repository;

    /** @var CommandBus */
    protected $bus;

    /**
     * Create a new command instance.
     *
     * @param FileRepository $fileRepository
     * @param CommandBus $bus
     * @param EntityManager $em
     */
    public function __construct(FileRepository $fileRepository, CommandBus $bus, EntityManager $em)
    {
        parent::__construct();
        $this->em         = $em;
        $this->repository = $fileRepository;
        $this->bus        = $bus;
    }

    /**
     * Execute the console command.
     *
     * @return mixed
     */
    public function handle()
    {
        $filesByWorkspace = $this->getRepository()->findUnprocessed();
        if ($filesByWorkspace->isEmpty()) {
            $this->info("No files to process at the moment.");
            return true;
        }

        $filesByWorkspace->each(function($file, $offset) {
            /** @var File $file */
            return $this->processFile($file);
        });

        return true;
    }

    /**
     * Process a single NMAP file
     *
     * @param File $file
     * @return bool
     */
    protected function processFile(File $file)
    {
        try {
            /** @var AbstractXmlParserService $service */
            $service = XmlParserFactoryService::getParserService($file->getScannerApp()->getName());

            /** @var Collection $xmlParserModels */
            $xmlParserModels = $service->processXmlFile($file);
        } catch (FileNotFoundException $e) {
            $this->error("Error processing file: $file: {$e->getMessage()}");
            return true;
        }

        if ($xmlParserModels->isEmpty()) {
            $this->warn("No models generated by file: $file.");
            return true;
        }

        // Intialise some counters
        $counters = new Collection([
            Asset::class                      => 0,
            Vulnerability::class              => 0,
            VulnerabilityReferenceCode::class => 0,
            SystemInformation::class          => 0,
        ]);
        $workspaceId = $file->getWorkspaceId();

        $currentUser = Auth::user();
        $fileUser    = $file->getUser();
        if (empty($currentUser) || !($currentUser instanceof User)
            || $currentUser->getId() !== $fileUser->getId()) {

            Auth::login($fileUser);
            
        }

        // Iterate over each model, extract and persist the relevant entities
        $xmlParserModels->each(function($model, $offset) use ($workspaceId, $file, $counters) {
            $this->processXmlParserModel($model, $workspaceId, $counters);
            return true;
        });

        // Move the file to the processed location
        $service->moveFileToProcessed($file);

        // No Assets successfully created :( reset the service models and return
        if ($counters->get(Asset::class, 0) === 0) {
            $this->error("Did not successfully create any Assets from file: {$file->getPath()}");
            $service->resetModels();
            return true;
        }

        // More Assets were found in the file that were created, i.e. some attempts to create Assets failed :/
        if ($counters->get(Asset::class, 0) !== $xmlParserModels->count()) {
            $failed = $xmlParserModels->count() - $counters->get(Asset::class, 0);
            $this->warn(
                "Failed to create $failed of {$xmlParserModels->count()} Assets found in file: {$file->getPath()}"
            );
        }

        $message = "Successfully created/updated {$counters->count()} of {$xmlParserModels->count()} Assets";
        if ($counters->get(SystemInformation::class, 0) !== 0) {
            $message .= ", {$counters->get(SystemInformation::class)} System Information entries";
        }

        if ($counters->get(Vulnerability::class, 0) !== 0) {
            $message .= ", {$counters->get(Vulnerability::class)} Vulnerabilities";
        }

        if ($counters->get(VulnerabilityReferenceCode::class, 0) !== 0) {
            $message .= ", {$counters->get(VulnerabilityReferenceCode::class)} Vulnerability Reference Codes";
        }

        $message .= " found in file: {$file->getPath()}";

        // All Assets that were found were successfully created :)
        $this->info($message);

        // Reset the collection of Models to an empty Collection in preparation from processing the next file.
        $service->resetModels();

        return true;
    }

    /**
     * Process the XML Parser Model
     *
     * @param CollectsScanOutput $model
     * @param int $workspaceId
     * @param Collection $counters
     * @return bool
     */
    protected function processXmlParserModel(CollectsScanOutput $model, int $workspaceId, Collection $counters): bool
    {
        // Instantiate a CreateAsset command and attempt to execute the command
        /** @var CollectsScanOutput $model */
        $assetDetails = $model->exportForAsset();

        // Get vulnerability, vulnerability reference and system information
        $vulnerabilityDetails     = $model->exportForVulnerability();
        $vulnerabilityRefDetails  = $model->exportForVulnerabilityReference();
        $systemInformationDetails = $model->exportForSystemInformation();

        // Save the Asset
        $asset = $this->sendCommandToBus(CreateAsset::class, $workspaceId, $assetDetails);
        // Make sure we got an Asset and not something else that would indicate a failure
        if (empty($asset) || !($asset instanceof Asset)) {
            return true;
        }

        // Add the asset to the collection
        $currentAssetCount = $counters->get(Asset::class, 0);
        $counters->put(Asset::class, $currentAssetCount + 1);

        $systemInformation = $this->sendCommandToBus(
            CreateSystemInformation::class, $asset->getId(), $systemInformationDetails
        );
        if (!empty($systemInformation)) {
            $currentSystemInformationCount = $counters->get(SystemInformation::class, 0);
            $counters->put(SystemInformation::class, $currentSystemInformationCount + 1);
        }

        $vulnerability = $this->sendCommandToBus(CreateVulnerability::class, $asset->getId(), $vulnerabilityDetails);
        if (empty($vulnerability) || !($vulnerability instanceof Vulnerability)) {
            return true;
        }

        // If there is associated vulnerability reference data in the model, save a new vulnerability reference
        $vulnerabilityReference = $this->sendCommandToBus(
            CreateVulnerabilityReference::class, $vulnerability->getId(), $vulnerabilityRefDetails
        );
        if (!empty($vulnerabilityReference)) {
            $currentVulnerabilityReferenceCount = $counters->get(VulnerabilityReferenceCode::class, 0);
            $counters->put(SystemInformation::class, $currentVulnerabilityReferenceCount + 1);
        }

        return true;
    }

    /**
     * Instantiate the relevant command and send it over the command bus
     *
     * @param string $commandClass
     * @param int $id
     * @param Collection $details
     * @return SystemComponent|false
     * @throws InvalidInputException
     */
    public function sendCommandToBus(string $commandClass, int $id, Collection $details)
    {
        if (!class_exists($commandClass) || !($commandClass instanceof CreateSomething)) {
            $this->error("Could not find command class: $commandClass.");
            return false;
        }

        if (!isset($id) || $details->isEmpty()) {
            $this->error("A required parameter is not set.");
            return false;
        }

        try {
            $command = new $commandClass($id, $details->toArray(), true);
            return $this->getBus()->handle($command);
        } catch (Exception $e) {
            $this->error("Error: {$e->getMessage()} when parsing file.");
            return false;
        }
    }

    /**
     * @return EntityManager
     */
    public function getEm()
    {
        return $this->em;
    }

    /**
     * @return FileRepository
     */
    public function getRepository()
    {
        return $this->repository;
    }

    /**
     * @return CommandBus
     */
    public function getBus()
    {
        return $this->bus;
    }
}
